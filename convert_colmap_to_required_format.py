#!/usr/bin/env python3
"""
Convert COLMAP output to the format required by EndoscopyDepthEstimation-Pytorch

COLMAP outputs:
- cameras.txt: Camera intrinsics
- images.txt: Camera poses
- points3D.txt: Sparse 3D points

Required format:
- camera_intrinsics_per_view: Simple text file with fx, fy, cx, cy
- motion.yaml: Camera poses in YAML format
- structure.ply: Already generated by COLMAP
- view_indexes_per_point: Which images see each point
- undistorted_mask.bmp: Binary mask of valid regions
- selected_indexes: List of frame indices
- visible_view_indexes: Indices of successfully registered frames
"""

import numpy as np
import yaml
import cv2
from pathlib import Path
import argparse
from collections import defaultdict


def read_colmap_cameras(cameras_file):
    """Read COLMAP cameras.txt"""
    cameras = {}
    with open(cameras_file, 'r') as f:
        for line in f:
            if line.startswith('#'):
                continue
            parts = line.strip().split()
            if len(parts) < 5:
                continue
            camera_id = int(parts[0])
            model = parts[1]
            width = int(parts[2])
            height = int(parts[3])
            params = [float(x) for x in parts[4:]]

            # Extract fx, fy, cx, cy based on camera model
            if model == 'PINHOLE':
                fx, fy, cx, cy = params[0], params[1], params[2], params[3]
            elif model == 'OPENCV':
                fx, fy, cx, cy = params[0], params[1], params[2], params[3]
            elif model == 'RADIAL':
                fx, cx, cy = params[0], params[1], params[2]
                fy = fx
            else:
                print(f"Warning: Unknown camera model {model}")
                fx, fy, cx, cy = params[0], params[0], width/2, height/2

            cameras[camera_id] = {
                'model': model,
                'width': width,
                'height': height,
                'fx': fx,
                'fy': fy,
                'cx': cx,
                'cy': cy,
                'params': params
            }
    return cameras


def read_colmap_images(images_file):
    """Read COLMAP images.txt"""
    images = {}
    with open(images_file, 'r') as f:
        lines = f.readlines()

    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('#') or not line:
            i += 1
            continue

        # Image line
        parts = line.split()
        image_id = int(parts[0])
        qw, qx, qy, qz = float(parts[1]), float(parts[2]), float(parts[3]), float(parts[4])
        tx, ty, tz = float(parts[5]), float(parts[6]), float(parts[7])
        camera_id = int(parts[8])
        image_name = parts[9]

        # Point line (skip it)
        i += 2

        # Convert quaternion to rotation matrix
        R = quat_to_rotation_matrix(qw, qx, qy, qz)
        t = np.array([[tx], [ty], [tz]])

        images[image_id] = {
            'name': image_name,
            'camera_id': camera_id,
            'R': R,
            't': t,
            'quat': (qw, qx, qy, qz),
            'position': (tx, ty, tz)
        }

    return images


def quat_to_rotation_matrix(w, x, y, z):
    """Convert quaternion to rotation matrix"""
    R = np.array([
        [1 - 2*y*y - 2*z*z, 2*x*y - 2*w*z, 2*x*z + 2*w*y],
        [2*x*y + 2*w*z, 1 - 2*x*x - 2*z*z, 2*y*z - 2*w*x],
        [2*x*z - 2*w*y, 2*y*z + 2*w*x, 1 - 2*x*x - 2*y*y]
    ])
    return R


def read_colmap_points3D(points3D_file):
    """Read COLMAP points3D.txt"""
    points = {}
    with open(points3D_file, 'r') as f:
        for line in f:
            if line.startswith('#'):
                continue
            parts = line.strip().split()
            if len(parts) < 8:
                continue

            point_id = int(parts[0])
            xyz = [float(parts[1]), float(parts[2]), float(parts[3])]
            rgb = [int(parts[4]), int(parts[5]), int(parts[6])]
            error = float(parts[7])

            # Track indices: pairs of (image_id, point2D_idx)
            track = []
            for i in range(8, len(parts), 2):
                if i+1 < len(parts):
                    image_id = int(parts[i])
                    point2D_idx = int(parts[i+1])
                    track.append((image_id, point2D_idx))

            points[point_id] = {
                'xyz': xyz,
                'rgb': rgb,
                'error': error,
                'track': track
            }

    return points


def convert_to_required_format(colmap_dir, output_dir, image_dir):
    """Convert COLMAP output to required format"""

    colmap_dir = Path(colmap_dir)
    output_dir = Path(output_dir)
    image_dir = Path(image_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    print("Reading COLMAP outputs...")
    cameras = read_colmap_cameras(colmap_dir / 'cameras.txt')
    images = read_colmap_images(colmap_dir / 'images.txt')
    points3D = read_colmap_points3D(colmap_dir / 'points3D.txt')

    print(f"Found {len(cameras)} cameras, {len(images)} images, {len(points3D)} 3D points")

    # 1. camera_intrinsics_per_view
    print("Writing camera_intrinsics_per_view...")
    # Assuming single camera (common for endoscopy)
    camera = list(cameras.values())[0]
    with open(output_dir / 'camera_intrinsics_per_view', 'w') as f:
        f.write(f"{camera['fx']}\n")
        f.write(f"{camera['fy']}\n")
        f.write(f"{camera['cx']}\n")
        f.write(f"{camera['cy']}\n")

    # 2. motion.yaml
    print("Writing motion.yaml...")
    poses_list = []
    image_list = sorted(images.items(), key=lambda x: x[1]['name'])

    for img_id, img_data in image_list:
        qw, qx, qy, qz = img_data['quat']
        tx, ty, tz = img_data['position']

        pose = {
            'position': {'x': float(tx), 'y': float(ty), 'z': float(tz)},
            'orientation': {'x': float(qx), 'y': float(qy), 'z': float(qz), 'w': float(qw)}
        }
        poses_list.append(pose)

    motion_data = {
        'header': {'seq': 0, 'stamp': 0.0, 'frame_id': ''},
        'poses[]': [f'poses[{i}]: ' for i in range(len(poses_list))]
    }

    # Write poses
    with open(output_dir / 'motion.yaml', 'w') as f:
        f.write('header: \n')
        f.write('  seq: 0\n')
        f.write('  stamp: 0.000000000\n')
        f.write('  frame_id: \n')
        f.write('poses[]:\n')
        for i, pose in enumerate(poses_list):
            f.write(f'  poses[{i}]: \n')
            f.write(f'    position: \n')
            f.write(f'      x: {pose["position"]["x"]}\n')
            f.write(f'      y: {pose["position"]["y"]}\n')
            f.write(f'      z: {pose["position"]["z"]}\n')
            f.write(f'    orientation: \n')
            f.write(f'      x: {pose["orientation"]["x"]}\n')
            f.write(f'      y: {pose["orientation"]["y"]}\n')
            f.write(f'      z: {pose["orientation"]["z"]}\n')
            f.write(f'      w: {pose["orientation"]["w"]}\n')

    # 3. Copy structure.ply (already in correct format)
    import shutil
    print("Copying structure.ply...")
    shutil.copy(colmap_dir / 'points3D.ply', output_dir / 'structure.ply')

    # 4. view_indexes_per_point
    print("Writing view_indexes_per_point...")
    # Create mapping from image_id to index
    image_id_to_idx = {img_id: idx for idx, (img_id, _) in enumerate(image_list)}

    with open(output_dir / 'view_indexes_per_point', 'w') as f:
        for point_id in sorted(points3D.keys()):
            point = points3D[point_id]
            view_indices = [image_id_to_idx[img_id] for img_id, _ in point['track'] if img_id in image_id_to_idx]
            f.write(' '.join(map(str, view_indices)) + ' -1\n')

    # 5. visible_view_indexes
    print("Writing visible_view_indexes...")
    visible_indices = list(range(len(image_list)))
    with open(output_dir / 'visible_view_indexes', 'w') as f:
        f.write(' '.join(map(str, visible_indices)))

    # 6. selected_indexes (assume stride=1, all frames selected)
    print("Writing selected_indexes...")
    with open(output_dir / 'selected_indexes', 'w') as f:
        f.write('1\n')  # stride
        for idx, (img_id, img_data) in enumerate(image_list):
            # Extract frame number from filename (e.g., 00004584.jpg -> 4584)
            frame_num = int(Path(img_data['name']).stem)
            f.write(f'{frame_num}\n')

    # 7. undistorted_mask.bmp (create from first image)
    print("Creating undistorted_mask.bmp...")
    first_image_name = image_list[0][1]['name']
    first_image_path = image_dir / first_image_name

    if first_image_path.exists():
        img = cv2.imread(str(first_image_path))
        # Create a simple mask (all white for now, adjust if needed)
        mask = np.ones((img.shape[0], img.shape[1]), dtype=np.uint8) * 255
        cv2.imwrite(str(output_dir / 'undistorted_mask.bmp'), mask)
    else:
        print(f"Warning: Could not find {first_image_path} to create mask")
        # Create default mask
        mask = np.ones((camera['height'], camera['width']), dtype=np.uint8) * 255
        cv2.imwrite(str(output_dir / 'undistorted_mask.bmp'), mask)

    # 8. Copy images to output directory
    print("Copying images...")
    for img_id, img_data in image_list:
        src = image_dir / img_data['name']
        dst = output_dir / img_data['name']
        if src.exists():
            shutil.copy(src, dst)

    print(f"\nConversion complete! Output saved to: {output_dir}")
    print("\nGenerated files:")
    for f in ['camera_intrinsics_per_view', 'motion.yaml', 'structure.ply',
              'view_indexes_per_point', 'visible_view_indexes', 'selected_indexes',
              'undistorted_mask.bmp']:
        print(f"  âœ“ {f}")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Convert COLMAP output to required format')
    parser.add_argument('--colmap_dir', type=str, required=True,
                        help='Path to COLMAP sparse reconstruction (contains cameras.txt, images.txt, points3D.txt)')
    parser.add_argument('--output_dir', type=str, required=True,
                        help='Output directory for converted files')
    parser.add_argument('--image_dir', type=str, required=True,
                        help='Directory containing original images')

    args = parser.parse_args()

    convert_to_required_format(args.colmap_dir, args.output_dir, args.image_dir)
